using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace TestGenerator.Lib
{

    public class TestsGenerator
    {
        const string test =
                          @"using System;
                            using System.Collections;
                            using System.Linq;
                            using System.Text;

                            namespace HelloWorld
                            {
                                class Program
                                {
                                    static void Main(string[] args)
                                    {
                                        Console.WriteLine(""Hello, World!"");
                                    }
                                }
                            }";

        public Dictionary<string, string> Generate(string file = test)
        {
            var resDictionary = new Dictionary<string, string>();
            SyntaxTree tree = CSharpSyntaxTree.ParseText(test);
            CompilationUnitSyntax root = tree.GetCompilationUnitRoot();

            var usings = root.Usings;
            var namespaces = root.DescendantNodes().Where(sn => sn is NamespaceDeclarationSyntax);

            foreach(NamespaceDeclarationSyntax ns in namespaces)
            {
                var classes = ns.DescendantNodes().OfType<ClassDeclarationSyntax>();
                foreach (var @class in classes)
                    resDictionary.Add(@class.Identifier.Text + "Test", GenerateTest(usings, ns, @class));
            }

            return resDictionary;
        }

        private string GenerateTest(IEnumerable<UsingDirectiveSyntax> usings, NamespaceDeclarationSyntax ns, ClassDeclarationSyntax @class)
        {
            usings = usings.Append(CreateUsingDirective("NUnit.Framework"));
            usings = usings.Append(CreateUsingDirective("Moq"));
            usings = usings.Append(CreateUsingDirective(FindFullNamespace(@class)));
            CompilationUnitSyntax cu = SyntaxFactory.CompilationUnit().AddUsings(usings.ToArray());

            NamespaceDeclarationSyntax testNamespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName($"{usings.Last().Name}.Tests"));
            ClassDeclarationSyntax testClass = SyntaxFactory.ClassDeclaration(@class.Identifier.Text + "Tests").AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword));
            testClass = testClass.AddMembers(GenerateMethods(@class));

            cu = cu.AddMembers(testNamespace.AddMembers(testClass));
            return cu.NormalizeWhitespace().ToFullString();
        }

        private UsingDirectiveSyntax CreateUsingDirective(string usingName)
        {
            NameSyntax qualifiedName = null;
            foreach (string id in usingName.Split('.'))
            {
                var name = SyntaxFactory.IdentifierName(id);
                if (qualifiedName != null)
                {
                    qualifiedName = SyntaxFactory.QualifiedName(qualifiedName, name);
                }
                else
                {
                    qualifiedName = name;
                }
            }

            return SyntaxFactory.UsingDirective(qualifiedName);
        }

        private string FindFullNamespace(ClassDeclarationSyntax @class)
        {
            string fullNS = "";

            while (!(@class.Parent is NamespaceDeclarationSyntax))
            {
                fullNS = fullNS.Insert(0, '.' + (@class.Parent as ClassDeclarationSyntax).Identifier.Text);
                @class = @class.Parent as ClassDeclarationSyntax;
            }
            fullNS = ((@class.Parent as NamespaceDeclarationSyntax).Name as IdentifierNameSyntax).Identifier.Text + fullNS;

            return fullNS;
        }

        private MethodDeclarationSyntax[] GenerateMethods(ClassDeclarationSyntax @class)
        {
            List<MethodDeclarationSyntax> testMethods = new List<MethodDeclarationSyntax>();
            var methods = @class.ChildNodes().OfType<MethodDeclarationSyntax>();

            foreach(var method in methods)
            {
                MethodDeclarationSyntax testMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.IdentifierName("void"), method.Identifier.Text + "Test");
                testMethod = testMethod.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword));
                testMethod = testMethod.AddAttributeLists(SyntaxFactory.AttributeList().AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Test"))));

                StatementSyntax statement = SyntaxFactory.ParseStatement("Assert.Fail(\"Autogenerated\");");
                testMethod = testMethod.AddBodyStatements(statement);
                testMethods.Add(testMethod);
            }

            return testMethods.ToArray();
        }

        private MemberDeclarationSyntax[] GenerateSetUp(ClassDeclarationSyntax @class)
        {
            List<MemberDeclarationSyntax> memberDeclarations = new List<MemberDeclarationSyntax>();
   
            MethodDeclarationSyntax setUpMethod = CreateMethodDeclaration(SyntaxKind.PublicKeyword, "void", "SetUp", "SetUp");
            memberDeclarations.Add(setUpMethod);
            if (@class.Modifiers.Contains(SyntaxFactory.Token(SyntaxKind.StaticKeyword)))
                return memberDeclarations.ToArray();

            memberDeclarations.Add(CreateFieldDeclaration(SyntaxKind.PrivateKeyword, @class.Identifier.Text, $"_{@class.Identifier.Text}UnderTest"));
            ConstructorDeclarationSyntax ctorSyntax = @class.ChildNodes().OfType<ConstructorDeclarationSyntax>()
                                                      .OrderBy(ctorSyn => ctorSyn.ParameterList.Parameters.Count)
                                                      .First();

            foreach(ParameterSyntax paramSyn in ctorSyntax.ParameterList.Parameters.Where(parameter => !parameter.Identifier.Text.StartsWith('I')))
            {
                setUpMethod = setUpMethod.AddBodyStatements(
                    CreateAssignmentStatement(
                        paramSyn.Type.ToString(),
                        paramSyn.Identifier.Text,
                        false,
                        "default"));
            }

            foreach(ParameterSyntax paramSyn in ctorSyntax.ParameterList.Parameters.Where(parameter => parameter.Identifier.Text.StartsWith('I')))
            {
                memberDeclarations.Add(
                    CreateFieldDeclaration(
                        SyntaxKind.PrivateKeyword,
                        $"Mock<{paramSyn.Type.ToString()}>",
                        CreateDecoratedName(paramSyn)));

                setUpMethod = setUpMethod.AddBodyStatements(
                                    CreateAssignmentStatement(
                                        "",
                                        CreateDecoratedName(paramSyn),
                                        true,
                                        $"Mock<{paramSyn.Type.ToString()}>"));
            }

            setUpMethod = setUpMethod.AddBodyStatements(
                CreateAssignmentStatement(
                    "",
                    $"_{@class.Identifier.Text}UnderTest",
                    true,
                    @class.Identifier.Text,
                    string.Join(
                        ", ",
                        ctorSyntax.ParameterList.Parameters
                        .Select(
                            paramSyn => paramSyn.Identifier.Text
                            .StartsWith('I') ?
                            CreateDecoratedName(paramSyn) :
                            paramSyn.Identifier.Text))));

            return memberDeclarations.ToArray();
        }

        private MethodDeclarationSyntax CreateMethodDeclaration(SyntaxKind accessModifier, string returnType, string methodName, string attributeName = null)
        {
            var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(returnType), methodName).AddModifiers(SyntaxFactory.Token(accessModifier));
            if (attributeName != null)
                method = method.AddAttributeLists(SyntaxFactory.AttributeList().AddAttributes(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName(attributeName))));
            return method;
        }

        private FieldDeclarationSyntax CreateFieldDeclaration(SyntaxKind accessModifier, string fieldType, string fieldName)
        {
            return SyntaxFactory.FieldDeclaration(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.ParseTypeName(fieldType))
                    .WithVariables(
                        SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>(
                            SyntaxFactory.VariableDeclarator(
                                SyntaxFactory.Identifier(fieldName)))))
                .AddModifiers(SyntaxFactory.Token(accessModifier));
        }

        private string CreateDecoratedName(ParameterSyntax paramSyn)
        {
            return $"_{paramSyn.Identifier.Text}_dependency";
        }

        private StatementSyntax CreateAssignmentStatement(string type, string var, bool isNew, string assignableVar, string invokeArgs = "")
        {
            return SyntaxFactory.ParseStatement(
                        string.Format(
                            "{0} {1} = {2} {3}{4};",
                            type,
                            var,
                            isNew ? "new" : "",
                            assignableVar,
                            isNew ? string.Format("({0})", invokeArgs) : ""));
        }
    }
}
